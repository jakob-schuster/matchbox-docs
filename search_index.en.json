[{"url":"https://jakob-schuster.github.io/matchbox-docs/guides/","title":"Guides","description":null,"body":"A collection of solutions to small bioinformatic problems, to guide you in writing your own matchbox scripts.\n","path":null},{"url":"https://jakob-schuster.github.io/matchbox-docs/guides/searching-for-primers/","title":"Searching for sequences","description":null,"body":"Often, we have known sequences such as primers that we want to search for in our reads.\n\n\n\n    \n        \n        \n        info\n        \n        \n        \n            The global error rate parameter will be used when searching for sequences. In this case, an error rate of 0.2 with this 20-bp primer sequence will allow a Levenshtein distance of 4 bp. \n        \n    \n\n\nReverse complementation\nIf we also want to search for the reverse complement of the primer:\n\nFiltering\nIf we want to filter our reads into different files:\n\n\n\n    \n        \n        \n        info\n        \n        \n        \n        If you're expecting FASTQ output, like in the line out!('primer.fq'), then you can't provide FASTA reads as input, because they don't have a quality score. Similarly, SAM output can only be produced from SAM input, since they carry more metadata than FASTQ. \n        \n    \n\n\nSearching for multiple sequences\nOften, we have multiple known sequences we want to search for.\n\nDiscovering arrangements of primers in reads\nInstead of writing out patterns for each primer, we can use the describe function to get counts for each arrangement of the primers in the data:\n\nThe optional arguments reverse_complement and error can be used to customise this search:\n\n","path":null},{"url":"https://jakob-schuster.github.io/matchbox-docs/guides/extracting-fixed-regions/","title":"Fixed-length regions","description":null,"body":"Sometimes we want to extract a fixed number of bases from a read. Fixed-length regions can be specified using vertical bars:\n\nFixed-length regions can be taken from either side of the read:\n\nIf we also want to separately extract the rest of the sequence:\n\nFixed-length regions around known sequences\nFixed-length regions can also be extracted from either side of known sequences:\n\n\n\n    \n        \n        \n        info\n        \n        \n        \n            The tag function allows you to easily append to a read's metadata. See Working with metadata. \n        \n    \n\n\n","path":null},{"url":"https://jakob-schuster.github.io/matchbox-docs/guides/demultiplexing/","title":"Demultiplexing","description":null,"body":"Often, we have a reference file of known sequences such as barcodes, and we want to assign each read to its barcode.\nBarcode discovery\nBefore loading a reference file, it can be useful to quantify the barcodes that are actually present in the reads. This may be used to create a subset of the barcode reference file, as per the approach of flexiplex.\nIf the barcode flanks a known sequence:\n\nSearching for barcodes from a reference file\nTypically, demultiplexing involves a list of known barcodes\nIf your barcodes are in FASTA format, the fasta function can be used. Then, to iterate over the barcodes, a pattern can be parameterised using for:\n\n\nAlternatively, CSV or TSV files can be used. The values returned by the csv and tsv functions contain fields as named in the CSV/TSV header. Hence, for the following CSV, the fields would be barcode_name and sequence.\n\n\nIn the above examples, each read is tagged with the name of its barcode, and all successfully demultiplexed reads are aggregated into demultiplexed.fq.\n\n\n    \n        \n        \n        info\n        \n        \n        \n            The fasta, csv and tsv functions load the entire reference file into memory at the start of execution. matchbox currently doesn't support reference files which are too large to load into memory!\n        \n    \n\n\nDemultiplexing into separate files\nIt can be preferable to create separate files for each barcode:\n\nMultiple barcodes from different barcode lists\nSometimes, multiple distinct barcodes are present in a read.\nIf two barcodes come from separate barcode lists, two references can be loaded in. Multiple for parameters can be given, separated by commas:\n\nMultiple barcodes from the same barcode list\nIf two barcodes are distinct barcodes from the same reference list, we can load the reference file once and then create two parameters over it:\n\nFinding the same barcode in multiple places\nIf we expect to find the exact same barcode in two places within a read, we can use a single parameter and search for it in multiple places in the read pattern:\n\nBarcodes with multiple fields\nSometimes a single reference contains multiple parts, which must all match in different places in a read.\n\n\n","path":null},{"url":"https://jakob-schuster.github.io/matchbox-docs/guides/working-with-metadata/","title":"Manipulating read metadata","description":null,"body":"Read fields\nReads have several fields that store metadata. Which fields are available depends on the type of input reads you provide.\n\nInput format\nFields\n\nFASTA(.fa, .fasta)\n    \n        \n            seq: Str\n            The sequence of the read.\n        \n        \n            id: Str\n            The read ID. Everything from &gt; to the first whitespace in the description line.\n        \n        \n            desc: Str\n            The description line. Everything after the read ID.\n        \n    \n\n\n\nFASTQ(.fq, .fastq)\n    \n        \n            seq: Str\n            The sequence of the read.\n        \n        \n            id: Str\n            The read ID. Everything from @ to the first whitespace in the description line.\n        \n        \n            desc: Str\n            The description line. Everything after the read ID.\n        \n        \n            qual: Str\n            The quality string.\n        \n    \n\n\n\nSAM(.sam, .bam)\n    \n        \n            id | qname: Str\n            The read ID. Defaults to '*' if unavailable.\n        \n        \n            flag: Num\n            Combination of bitwise flags.\n        \n        \n            rname: Str\n            Name of the reference sequence to which the read is aligned. Defaults to '*' if unavailable or unmapped.\n        \n        \n            pos: Num\n            1-based leftmosed mapping position of the first CIGAR operation that consumes a reference base. Defaults to 0 if unmapped.\n        \n        \n            mapq: Num\n            Mapping quality.\n        \n        \n            cigar: Str\n            CIGAR string.\n        \n        \n            rnext: Str\n            Reference sequence name of the primary alignment of the next read in the template. Defaults to '*' if unavailable or unmapped.\n        \n        \n            pnext: Num\n            1-based position of the primary alignment of the next read in the template. Defaults to 0 if unavailable.\n        \n        \n            tlen: Num\n            Signed observed template length. Defaults to 0 if unavailable.\n        \n        \n            seq: Str\n            The sequence of the read.\n        \n        \n            qual: Str\n            The quality string.\n        \n        \n            desc: Str\n            The optional fields, as a single string.\n        \n    \n\n\n\nPaired(any formats)\n    \n        \n            r1: Read\n            The first read, from the file given as mandatory argument.\n        \n        \n            r2: Read\n            The second read, from the file given via the --paired-with optional argument.\n        \n    \n\n\n\nReverse-complementing\nReads can be reverse-complemented. For FASTA reads, this reverse-complements the sequence. For FASTQ and SAM reads, it additionally reverses the quality score, so that the bases still correctly correspond to quality score characters.\n\nTagging\nInformation can be added to the description line of reads, such as a UMI or barcode, or any other data derived from processing with matchbox.\n\n\n\n    \n        \n        \n        info\n        \n        \n        \n            The string given to tag is appended to the read's desc, separated by a space. To change this prefix (e.g. when adding an optional field to a SAM read, which are tab-delimited), the optional argument prefix can be set. \n        \n    \n\n\n","path":null},{"url":"https://jakob-schuster.github.io/matchbox-docs/guides/command-line-arguments/","title":"Command-line arguments","description":null,"body":"When writing matchbox scripts intended for others to run, or to be embedded in pipelines, it can be useful to make some variables accessible to users on the command line, so they can change them when running your script without having to edit the script itself.\nThe built-in args variable can be used for this purpose. It is a Record value accessible within the matchbox script, whose fields come from the command line argument --args.\nIn the following script, a primer is located and 10 bp following it are extracted:\n\nTo run the script, the primer argument must be provided at the command line:\n\nWe could make the script more flexible by allowing the user to specify the barcode length:\n\nWhen multiple arguments are given, they're separated by commas.\n\n","path":null},{"url":"https://jakob-schuster.github.io/matchbox-docs/","title":"Quick start","description":null,"body":"Welcome to the official user documentation for matchbox, a flexible processor for FASTA/FASTQ/SAM/BAM files.\nYou could use matchbox for:\n\nQuick, error-tolerant searches for primers and known sequences\nValidating the structure of your reads\nQuantifying and filtering out sequencing artefacts\nDemultiplexing even the most complex barcoding schemes\n\n\nInstallation\nInstall matchbox via cargo, the package manager for Rust:\n\nCommand-line usage\nmatchbox takes in reads, in FASTA, FASTQ, SAM or BAM formats. If no file path is given, matchbox expects to receive reads from stdin.\nmatchbox also requires a configuration script, written in the matchbox scripting language as a .mb file. This script will tell matchbox how to process your reads.\n\nPaired-end reads\nIf your reads are paired-end, the --paired-with parameter can be used.\n\nError tolerance\nWhen performing pattern-matching, matchbox tolerates insertions, deletions and substitutions. The global error rate is used for all sequences.\n\n\n","path":null},{"url":"https://jakob-schuster.github.io/matchbox-docs/reference/","title":"Reference","description":null,"body":"A complete reference guide for the Matchbox language. Intended for looking up specific details and functions.\n","path":null},{"url":"https://jakob-schuster.github.io/matchbox-docs/reference/statements/","title":"Statements","description":null,"body":"A matchbox script is a sequence of statements.\nEach time a read is processed, all the statements are executed from top to bottom.\n\nAssigning variables\nA variable name can be assigned to the value of an expression.\nVariable names can include letters, numbers and underscores. A name must start with a letter or an underscore. Variable names must be unique, and can't be overwritten.\n\n\nProducing output\nSome expressions produce output, which accumulates across all of the input reads. Summary statistics, trimmed read files and the standard output stream are all examples of outputs in matchbox.\nFunctions that produce output have exclamation marks after their name. Only expressions that produce output are allowed at the statement level.\n\n\n\n\nBranching with conditionals\nif statements can be used to ensure some statements only execute when certain conditions are met.\nA Bool expression can be used in a conditional.\n\nif statements can have an else branch.\n\nAlternatively, pattern matching can be performed on an expression using the matches keyword. Reads can be pattern-matched with error tolerance, and trimmed regions can be extracted. For more information, see Patterns.\n\n","path":null},{"url":"https://jakob-schuster.github.io/matchbox-docs/reference/patterns/","title":"Patterns","description":null,"body":"matchbox's key feature is the ability to pattern-match on sequences, while tolerating mismatches and extracting particular slices of reads.\nWith pattern matching, matchbox can be used to filter, trim or demultiplex reads.\n\nBranches\nPattern-matching takes place in the branches of an if .. matches statement:\n\nBranches are separated by semicolons or newlines. Each branch is tried in order, until one is successful. Only the first successful branch will be executed.\n\n\n    \n        \n        \n        info\n        \n        \n        \n            When a pattern matches multiple places in a single read (e.g. if the pattern above is used, and a read contains multiple polyA regions), then the body of the branch is executed for all instances of the match. This may cause the same read to produce multiple outputs.\n        \n    \n\n\nIf you want to trigger multiple statements from a single branch, use curly braces:\n\n\nPatterns and regions\nA pattern contains a series of regions enclosed in square brackets []. Patterns are comprised of several basic regions:\n\n    Name\n    Syntax\n    Description\n    \n        Wild\n        _\n        Matches any number of any nucleotides.\n    \n    \n        Fixed-length\n        |n||n:r|\n        Matches exactly n nucleotides, where n is an expression of type Num. Optionally, may contain another region r inside it.\n    \n    \n        Known sequence\n        s\n        Matches a known sequence s, where s is an expression of type Str. This may be a sequence literal such as AAAAAAAA, or a variable name such as primer. Allows d base pairs of edit distance, where d is the length of s times the global error rate.\n    \n    \n        Known sequence with specified error rate\n        s~n\n        Matches a known sequence s, while overriding the error rate with n. s is an expression of type Str, and n is an expression of type Num. Allows d base pairs of edit distance, where d is the length of s times the specified error rate n.\n    \n    \n        Named\n        a:r\n        Matches against the inner region r, and assigns the name a to refer to the matched slice of the read.\n    \n    \n        Grouped\n        (r*)\n        A sub-pattern, consisting of a series of regions.\n    \n\nThe whole pattern acts like a schematic for the read, representing the whole read from left to right.\nHere are some examples of patterns, and how to read them:\n\n    Example\n    Description\n    \n        [_]\n        Any read, of any length.\n    \n    \n        [|10|]\n        A read of exactly 10 bp.\n    \n    \n        [|10| _]\n        A read with at least 10 bp at the start.\n    \n    \n        [first:|10| _]\n        A read with at least 10 bp at the start. Extract these first 10 bp, and call the slice first.\n    \n    \n        [first:|10| rest:_]\n        A read with at least 10 bp at the start. Extract these first 10 bp, and call the slice first. Extract the rest of the read, and call it rest.\n    \n    \n        [_ AAAAAAAAAA _]\n        A read containing the sequence AAAAAAAAAA.\n    \n    \n        [_ AAAAAAAAAA~0.2 _]\n        A read containing the sequence AAAAAAAAAA, with error rate 0.2.\n    \n    \n    \n        [fst:_ AAAAAAAAAA _]\n        A read containing the sequence AAAAAAAAAA. Extract the bases before the sequence, and call them fst.\n    \n    \n        [_ AAAA _ TTTT _]\n        A read containing the sequence AAAA, and later, TTTT.\n    \n    \n        [_ AAAA mid:_ TTTT _]\n        A read containing the sequence AAAA, and later, TTTT. Take the bases in between and call the slice mid.\n    \n    \n        [|40:(_ AAAA _)| _]\n        A read with at least 40 bp, which contains the sequence AAAA in the first 40 bp.\n    \n    \n        [|40:(_ AAAA x:_)| _]\n        A read with at least 40 bp, which contains the sequence AAAA in the first 40 bp. Extract the remaining bases from after the sequence AAAA up to the 40th base, and call the slice x.\n    \n\n\n\n    \n        \n        \n        info\n        \n        \n        \n            A fixed-length pattern |n| cannot be placed between two wild regions. It must be anchored on at least one side by either end of the read, or by a known sequence. Otherwise, a pattern like [_ |10| _] could be used to denote \"all possible selections of 10 bp from the read\". Currently, matchbox rejects this as it would be computationally expensive and probably confusing.\n        \n    \n\n\nParameters using for\nPatterns can also be parameterised, useful when demultiplexing or matching against a list of known sequences.\n\nUsing the syntax for bc in bcs, a name bc is bound to a single value from the list of values bcs. The name bc can then be used in the body of the branch.\n\n\n    \n        \n        \n        info\n        \n        \n        \n            When multiple values from the list could be used to satisfy the pattern (e.g. when multiple barcodes match in a read), the body of the branch is executed for all values that satisfy the pattern.\n        \n    \n\n\n","path":null},{"url":"https://jakob-schuster.github.io/matchbox-docs/reference/types/","title":"Types","description":null,"body":"In matchbox, each variable has a type, and each function has a type signature, only accepting arguments of the expected types. This allows matchbox to catch errors when the program starts, and offer helpful error messages. Most programming languages have types, although not all languages enforce them.\nGenerally, matchbox users don't need to worry about learning the types. However, understanding them may help you interpret error messages and put together more complex scripts.\n\n\nBoolean Bool\nA Boolean value. Either true or false.\n\n\n\n\nNumeric Num\nA numeric value. Can be negative, can include a decimal component. Represented internally as a 32-bit floating point number.\n\n\n\n\nString Str\nA string value, consisting of a sequence of ASCII characters. May represent a nucleotide sequence, or more generally any string data.\nStrings must be constructed using single quotes; for example, 'hello world'. Values can be inserted into strings using curly braces {}.\n\n\n\n\nList []\nA list of values all belonging to the same type.\nLists can be iterated over when pattern matching, useful when working with barcodes.\n\n\n\n\n\nRecord {}\nA set of fields, each of which has a name and stores a value. Used for grouping related data together. Fields can be accessed using a dot.\n\n\n\n\n\n\n\nRead Read\nReads are a special kind of record to represent a sequencing read.\nReads contain a seq field, and they can be sliced, reverse-complemented and pattern-matched.\nDifferent input formats will produce different kinds of Read. See Manipulating read metadata.\n\n\nAdvanced types\nOnly the above types are relevant to matchbox users; the remaining types are only really relevant to those working on the matchbox backend. Don't worry if they seem confusing!\n\n\nFunction (..) -&gt; ..\nA function, which can be applied to a sequence of arguments to return a value. Each function expects arguments of a particular type, and guarantees a return value of a particular type.\nA function of type (Num, Num) -&gt; Str takes two arguments of type Num and returns a value of type Str.\nAn example of such a function is:\n\nFunctions can also have optional parameters. A function of the type (Num, opt_arg: Num = 0) -&gt; Num has one mandatory positional argument, and one optional argument called opt_arg, of type Num, with the default value 0.\nFor two function types to be equivalent:\n\nThey must have the same number of mandatory positional arguments, and the types of each argument must be equivalent.\nThey must have the same optional named arguments, with equivalent names, types, and values.\nThey must have equivalent return types.\n\n\n\n\n\nAny Any\nA value of any type. Concrete values will always have a more specific type than Any; it merely exists so that some functions can have sufficiently generic type signatures. For example, to_str can convert any value to a Str regardless of its value, so its type is (Any) -&gt; Str.\n\n\n\nType Type\nA value which is itself a type. All instances of the above types (e.g. Str, { age: Num }, (Bool, Bool) -&gt; Bool) are themselves values of this type. Hence, you can create type aliases, by assigning a variable to a type:\n\nUsers probably shouldn't worry about this! But treating types as values is helpful in writing functions whose types depend on the evaluation of other functions.\nFor example, the function csv_ty takes a filename, opens it as a CSV, and returns a record type with each of the CSV's columns as a Str field. Therefore, csv_ty has the type (Str) -&gt; Type.\n\nThe csv function loads a CSV and produces a list of records, where the type of each record depends on executing csv_ty on the file. Hence, the type of csv is [csv_ty(filename)] which evaluates to a concrete type in the presence of a specific filename.\n\nWe do this so that, if a user loads a CSV and tries to access a field which doesn't exist in their particular CSV, matchbox can give them a type error.\n\n\n","path":null},{"url":"https://jakob-schuster.github.io/matchbox-docs/reference/expressions/","title":"Expressions","description":null,"body":"Expressions are the smallest unit of matchbox syntax.\n\n\n\nVariables\nA variable name, defined earlier in the script.\nVariable names can include letters, numbers and underscores. A name must start with a letter or an underscore. Variable names must be unique, and can't be overwritten.\n\n\n\n\nBoolean literals\nThere are only two Bool literals: true and false.\n\n\n\nNumeric literals\nNumeric literals can be negative, and can include a decimal component.\n\n\n\n\nString literals\nStrings must be constructed using single quotes; for example, 'hello world'. Values can be inserted into strings using curly braces {}.\n\n\n\n\nList literals\nList literals are a set of square brackets, containing a number of values. All values must be of the same type.\n\n\n\n\nRecord literals\nRecord literals are a set of curly braces, containing a number of fields. Each field has a name and an expression, separated by equals.\nFields can be accessed using a dot.\n\n\n\n\n\nFunction application\nA function can be applied by writing the function name followed by parentheses enclosing a comma-separated list of arguments.\n\nAlternatively, a function can be applied with the first argument in front and a dot before the function name. All of the remaining arguments are still written inside the parentheses.\n\nSimilarly, the pipe operator |&gt; can also be used to apply functions.\n\nSome functions take optional named arguments. These must be given after all the mandatory arguments. The optional arguments themselves can then be given in any order.\n\n\n\n\nOperators\nA number of built-in common operators can be used. They are applied prefix or infix as appropriate.\n\nSome operators bind more tightly than others. The full list of operators is given below, from tightest to loosest precedence.\n\nPrecedence\nOperators\n\n0\n    All other expressions\n    \n\n\n\n\n\n1\n    \n        \n             -Num\n            Unary negation\n        \n        \n             -( Str | Read )\n            Reverse-complementation\n        \n        \n             not Bool\n            Logical NOT\n        \n    \n\n\n\n2\n    \n        \n            Num * Num\n            Multiplication\n        \n        \n            Num / Num\n            Division\n        \n        \n            Num % Num\n            Modulo\n        \n    \n\n\n\n3\n    \n        \n            Num + Num\n            Addition\n        \n        \n            Num - Num\n            Subtraction\n        \n    \n\n\n\n4\n    \n        \n            Num &lt; Num\n            Less than\n        \n        \n            Num &gt; Num\n            Greater than\n        \n        \n            Num &lt;= Num\n            Less than or equal\n        \n        \n            Num &gt;= Num\n            Greater than or equal\n        \n    \n\n\n\n5\n    \n        \n            Any == Any\n            Equality\n        \n        \n            Any != Any\n            Inequality\n        \n    \n\n\n\n6\n    \n        \n            Bool and Bool\n            Logical AND\n        \n    \n\n\n\n7\n    \n        \n            Bool or Bool\n            Logical OR\n        \n    \n\n\n\n","path":null},{"url":"https://jakob-schuster.github.io/matchbox-docs/reference/functions/","title":"Function list","description":null,"body":"Functions are used to manipulate and transform data. Most of the time, users will be applying built-in matchbox functions. This list includes every built-in function with examples.\n\n\n\n\nceil: Num\nRounds a number up to the nearest integer value.\n\nParameter\nDescription\n\nn: NumThe number to round.\n\n\n\n\n\n\n\n\nconcat: Read\nConcatenates two reads together.\n\nParameter\nDescription\n\nr1: ReadThe first read.\n\n\nr2: ReadThe second read.\n\n\n\n\n\n\n\n\n\ncontains: Bool\nChecks whether a value is present in a list.\n\nParameter\nDescription\n\nlist: [Any]The list to search through.\n\n\nval: AnyThe value to search for.\n\n\n\n\n\n\n\n\ncount_matches: Num\nCounts the number of discrete times a sequence can be found in a read.\n\nParameter\nDescription\n\nread: ReadThe read to match against.\n\n\nseq: StrThe sequence to search for.\n\n\nerror_rate: NumThe allowed error rate.\n\n\n\n\n\ncsv: [Record]\nOpens a CSV and produces a list of records. The field names of each record correspond to the header names of the CSV, and the values correspond to the values found on each row. This processing occurs once, at the start of execution. The entire CSV is loaded into memory.\n\nParameter\nDescription\n\nfilename: StrThe CSV file to open.\n\n\n\n\n\n\n\n\ncount!: Effect\nCollects all of the values sent to count! across all of the reads. Tallies up the number of times each unique value is sent. At the end of execution, prints out a table of counts for each value.\nCan be used for quantifying how many reads match certain criteria, or for counting occurrences of sequences such as barcodes. To generate multiple seperate counts tables from a single pass, the name parameter can be used to identify different global counts variables. Each name will correspond to a fresh table.\n\nParameter\nDescription\n\nval: AnyThe value to be counted.\n\n\nname: Str = 'default'The name of the global counts matrix to store the value into. Multiple tables of counts can be generated, using different names.\n\n\n\n\n\n\n\n\n\ndescribe: Str\nSearches for a set of sequences within a read's seq field, and returns the pattern which most precisely describes the read, as a Str. Very useful for exploring the arrangement of known primers and static regions in your data!\nEach search term is searched within the read. If reverse_complement is true, the reverse-complement sequences are also searched. Edit distance is allowed in proportion to the length of each search term sequence and the error parameter. Any matches are then concatenated together to produce a pattern string which describes the read in terms of the searched sequences.\n\nParameter\nDescription\n\nread: ReadThe read to describe.\n\n\nsearch_terms: RecordThe set of terms to search for. Each field of the struct must have a Str value, which represents the sequence to search for. Each field's name is used as a label for the sequence in the pattern.\n\n\nreverse_complement: Bool = falseWhether to additionally search for the reverse complement of each search term.\n\n\nerror: Num = 0Error rate proportion to allow when searching for each search term.\n\n\n\n\n\n\n\n\ndistance: Num\nCalculates the global edit distance between two strings.\n\nParameter\nDescription\n\ns0: StrThe first string.\n\n\ns1: StrThe second string.\n\n\n\n\n\n\n\n\nfails_platform_quality_checks: Bool\nChecks whether a BAM/SAM flag indicates that a read fails the platform quality checks.\n\nParameter\nDescription\n\nflag: NumSAM/BAM flag.\n\n\n\n\n\n\nfasta: [Read]\nOpens a FASTA and produces a list of reads, each one containing seq, id and desc fields. This processing occurs once, at the start of execution. The entire TSV is loaded into memory.\n\nParameter\nDescription\n\nfilename: StrThe TSV file to open.\n\n\n\n\n\n\n\n\nfind_first: Num\nSearches for a substring within a string. If the substring is present, returns the first 0-based position within the string where the substring could be found. If the substring is not present, returns -1.\n\nParameter\nDescription\n\ns0: StrThe string to search through.\n\n\ns1: StrThe substring to search for in s0.\n\n\n\n\n\n\n\n\nfind_last: Num\nSearches for a substring within a string. If the substring is present, returns the last 0-based position within the string where the substring could be found. If the substring is not present, returns -1.\n\nParameter\nDescription\n\ns0: StrThe string to search through.\n\n\ns1: StrThe substring to search for in s0.\n\n\n\n\n\n\n\n\nfirst_in_pair: Bool\nChecks whether a BAM/SAM flag indicates that a read is the first in a pair.\n\nParameter\nDescription\n\nflag: NumSAM/BAM flag.\n\n\n\n\n\n\nfloor: Num\nRounds a number down to the nearest integer value.\n\nParameter\nDescription\n\nn: NumThe number to round.\n\n\n\n\n\n\n\n\nmapped_in_proper_pair: Bool\nChecks whether a BAM/SAM flag indicates that a read is mapped in a proper pair.\n\nParameter\nDescription\n\nflag: NumSAM/BAM flag.\n\n\n\n\n\n\nmate_reverse_strand: Bool\nChecks whether a BAM/SAM flag indicates that a read's pair is on the reverse strand.\n\nParameter\nDescription\n\nflag: NumSAM/BAM flag.\n\n\n\n\n\n\nmate_unmapped: Bool\nChecks whether a BAM/SAM flag indicates that a read's pair is unmapped.\n\nParameter\nDescription\n\nflag: NumSAM/BAM flag.\n\n\n\n\n\n\nmax: Num\nTakes the maximum of a list of numbers. When supplied with an empty list, throws an error.\n\nParameter\nDescription\n\nl: [Num]The list to compute the maximum of.\n\n\n\n\n\n\nmean: Num\nTakes the mean of a list of numbers. When supplied with an empty list, throws an error.\n\nParameter\nDescription\n\nl: [Num]The list to compute the mean of.\n\n\n\n\n\n\nmean!: Effect\nCollects all of the numeric values sent to mean! across all of the reads. To simultaneously calculate multiple means, the name parameter can be used. At the end of execution, prints out the mean and variance.\nTo avoid having to store all the numeric values, variance is calculated using Welford's online algorithm.\n\nParameter\nDescription\n\nnum: NumThe number to contribute to the mean.\n\n\nname: Str = 'default'The name of the global variable to store the mean into. Multiple means can be calculated at once, using different names.\n\n\n\n\n\n\n\nmin: Num\nTakes the minimum of a list of numbers. When supplied with an empty list, throws an error.\n\nParameter\nDescription\n\nl: [Num]The list to compute the minimum of.\n\n\n\n\n\n\nnot_primary_alignment: Bool\nChecks whether a BAM/SAM flag indicates that a read is not the primary alignment.\n\nParameter\nDescription\n\nflag: NumSAM/BAM flag.\n\n\n\n\n\n\nout!: Effect\nPrints any value to a file. Based on the filename, the format of the output will be inferred. When the filetype denotes FASTA, FASTQ or SAM format, the value provided must be a read containing the following fields:\n\nInput format\nFields\n\nFASTA(.fa, .fasta)\n    \n        \n            seq: Str\n        \n        \n            id: Str\n        \n        \n            desc: Str\n        \n    \n\n\n\nFASTQ(.fq, .fastq)\n    \n        \n            seq: Str\n        \n        \n            id: Str\n        \n        \n            desc: Str\n        \n        \n            qual: Str\n        \n    \n\n\n\nSAM(.sam, .bam)\n    \n        \n            id | qname: Str\n        \n        \n            flag: Num\n        \n        \n            rname: Str\n        \n        \n            pos: Num\n        \n        \n            mapq: Num\n        \n        \n            cigar: Str\n        \n        \n            rnext: Str\n        \n        \n            pnext: Num\n        \n        \n            tlen: Num\n        \n        \n            seq: Str\n        \n        \n            qual: Str\n        \n        \n            desc: Str\n        \n    \n\n\n\nIf the file is any other format, it is treated as a plain text file, and any values sent to it are simply printed directly and separated by newlines.\nA file is only created when the first\n\nParameter\nDescription\n\nval: AnyThe value to print.\n\n\nfilename: StrThe name of the file to write to.\n\n\n\n\n\n\n\n\npaired: Bool\nChecks whether a BAM/SAM flag indicates that a read is paired.\n\nParameter\nDescription\n\nflag: NumSAM/BAM flag.\n\n\n\n\n\n\npcr_or_optical_duplicate: Bool\nChecks whether a BAM/SAM flag indicates that a read is a PCR or optical duplicate.\n\nParameter\nDescription\n\nflag: NumSAM/BAM flag.\n\n\n\n\n\n\nrename: Read\nCopies a read and changes its ID.\n\nParameter\nDescription\n\nread: ReadThe read to rename.\n\n\nrename: StrThe new read ID.\n\n\n\n\n\n\n\n\nreverse_strand: Bool\nChecks whether a BAM/SAM flag indicates that a read is on the reverse strand.\n\nParameter\nDescription\n\nflag: NumSAM/BAM flag.\n\n\n\n\n\n\nround: Num\nRounds a number to the nearest integer value.\n\nParameter\nDescription\n\nn: NumThe number to round.\n\n\n\n\n\n\n\n\nsecond_in_pair: Bool\nChecks whether a BAM/SAM flag indicates that a read is the second in a pair.\n\nParameter\nDescription\n\nflag: NumSAM/BAM flag.\n\n\n\n\n\n\nslice: Str\nTakes a slice of a string. Inclusive of start position, exclusive of end position.\n\nParameter\nDescription\n\ns: StrThe string to slice.\n\n\nstart: NumThe start position.\n\n\n\nend: NumThe end position.\n\n\n\n\n\n\n\n\nstdout!: Effect\nPrints any value directly to stdout.\n\nParameter\nDescription\n\nval: AnyThe value to print.\n\n\n\n\n\n\n\n\nstr_concat: Str\nConcatenates two strings.\n\nParameter\nDescription\n\ns0: StrThe first string.\n\n\ns1: StrThe second string.\n\n\n\n\n\n\n\n\nsupplementary_alignment: Bool\nChecks whether a BAM/SAM flag indicates that a read is a supplementary alignment.\n\nParameter\nDescription\n\nflag: NumSAM/BAM flag.\n\n\n\n\n\n\ntag: Read\nCopies a read and appends a string to the end of its description line. A space is added.\n\nParameter\nDescription\n\nread: ReadThe read to tag.\n\n\ntag: StrThe string to append to the read's description line.\n\n\nprefix: Str = ' 'A string inserted between the existing description line and the new tag.\n\n\n\n\n\n\n\n\nto_lower: Str\nConverts a string to lower-case. Non-alphabetic characters are unaffected.\n\nParameter\nDescription\n\ns: StrThe string to convert to lower-case.\n\n\n\n\n\n\n\nto_num: Num\nParses a Str into a Num. When given a value that can't be parsed into a floating-point number, throws an error.\n\nParameter\nDescription\n\ns: StrThe string to parse.\n\n\n\n\n\n\n\n\nto_str: Str\nConverts any value to a Str. Equivalent to formatting the value in a string literal (e.g. '{val}').\n\nParameter\nDescription\n\nv: AnyThe value to convert.\n\n\n\n\n\n\n\n\nto_upper: Str\nConverts a string to upper-case. Non-alphabetic characters are unaffected.\n\nParameter\nDescription\n\ns: StrThe string to convert to upper-case.\n\n\n\n\n\n\n\n\nto_qscores: [Num]\nTakes a string of Phred quality scores and converts each character to its corresponding quality score (0-40). When supplied with a character outside the expected range of Phred characters, throws an error.\n\nParameter\nDescription\n\nqual: StrThe quality string to convert.\n\n\n\n\n\n\ntranslate: Str\nTranslates a string from nucleotide to protein sequence. Naively assumes that you've given it a string representing a valid sequence of nucleotides. Stop codons are represented by a single character given by the stop_codon argument (by default, hyphen -). When the input string contains an invalid codon (i.e. when the input string contains   characters aside from A, C, T and G), this is represented by a single character given by the illegal_codon argument.\n\nParameter\nDescription\n\nseq: StrThe sequence to translate.\n\n\nstop_codon: Str = '-'The character used to represent a stop codon.\n\n\nillegal_codon: Str = '?'The character used to represent an attempt to translate a codon containing non-nucleotide characters.\n\n\n\n\n\n\n\n\ntsv: [Record]\nOpens a TSV and produces a list of records. The field names of each record correspond to the header names of the TSV, and the values correspond to the values found on each row. This processing occurs once, at the start of execution. The entire TSV is loaded into memory.\n\nParameter\nDescription\n\nfilename: StrThe TSV file to open.\n\n\n\n\n\n\n\nunmapped: Bool\nChecks whether a BAM/SAM flag indicates that a read is unmapped.\n\nParameter\nDescription\n\nflag: NumSAM/BAM flag.\n\n\n\n\n\n","path":null}]